from _common import setup_path


setup_path()

from compare_selection_methods import run_comparison


def create_markdown_table(results):
    """Создает строку с таблицей в формате Markdown из списка результатов."""
    # Заголовок таблицы
    header = "| Метод              | Найденный X        | Итераций | Время (μs/запуск) | Итоговый A3_delt |"
    separator = "|:-------------------|:-------------------|:---------|:------------------|:-----------------|"

    # Строки таблицы
    rows = []
    for res in results:
        # Форматируем значения для красивого вывода
        method = f"**{res['Метод']}**"  # Выделяем название метода жирным

        x_val = res["Найденный X"]
        x_str = f"`{x_val:.8f}`" if isinstance(x_val, float) else str(x_val)

        iters_str = str(res["Итераций"])

        time_val = res["Время (μs/запуск)"]
        time_str = f"{time_val:.4f}" if isinstance(time_val, float) else str(time_val)

        delta_val = res["Итоговый A3_delt"]
        delta_str = f"{delta_val:.10f}" if isinstance(delta_val, float) else str(delta_val)

        # Собираем строку
        rows.append(f"| {method:<18} | {x_str:<18} | {iters_str:<8} | {time_str:<17} | {delta_str:<16} |")

    return "\n".join([header, separator, *rows])

def generate_report_file(results, filename="report.md"):
    """Генерирует полный файл отчета в формате Markdown."""
    table_md = create_markdown_table(results)

    report_content = f"""
# Сравнение методов решения

В этом файле представлены результаты сравнения производительности и точности трех методов для решения уравнения, заданного в `problem.py`.

**Цель:** найти такое значение `X`, при котором `A3_delt` будет равен **0.001**.

## Итоговая таблица

{table_md}

---

## Анализ и выводы

### 1. Аналитический метод
- **Скорость:** Абсолютный лидер. Решение находится за одну математическую операцию, без итераций.
- **Точность:** Максимально возможная, так как это прямое обращение формулы. Результат является эталоном.
- **Применимость:** Ограничена. Подходит только для тех задач, где можно вывести явную обратную функцию. В данном случае это было возможно.

### 2. Метод Дихотомии (Половинного деления)
- **Скорость:** Самый медленный из итерационных методов. Требует наибольшее количество итераций для достижения заданной точности.
- **Надежность:** Очень высокая. Метод гарантированно сходится, если на концах начального отрезка `[a, b]` значения функции имеют разный знак.
- **Применимость:** Широкая. Не требует производной, что делает его простым в реализации для сложных функций. Идеален, когда надежность важнее скорости.

### 3. Метод Ньютона (Метод касательных)
- **Скорость:** Очень быстрая сходимость (квадратичная). Ему потребовалось всего несколько итераций, чтобы достичь высокой точности.
- **Точность:** Очень высокая, сравнимая с аналитическим решением.
- **Применимость:** Требует вычисления производной функции. Сходимость сильно зависит от выбора начального приближения.

## Общий вывод

- **Аналитический метод** — идеальный вариант, если он существует.
- **Метод Ньютона** — лучший выбор для большинства практических задач, где требуется высокая скорость и известна производная.
- **Метод Дихотомии** — надежный "запасной" вариант, когда другие методы не работают или их сложно применить.
"""

    try:
        with open(filename, "w", encoding="utf-8") as f:
            f.write(report_content.strip())
        print(f"Отчет успешно сгенерирован в файле: {filename}")
    except OSError as e:
        print(f"Ошибка при записи файла: {e}")


if __name__ == "__main__":
    simulation_results = run_comparison()
    generate_report_file(simulation_results)

